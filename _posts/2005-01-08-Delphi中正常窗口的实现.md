---
layout:   post
title:  "Delphi中正常窗口的实现"
subtitle:   "——谨以怀念写Delphi的青春岁月"
date:   2005-01-08 00:57:00
author:   "eagleboost"
header-img: "img/post-bg-belltower.jpg"
tags:
  - 窗口动画
  - 正常排列平铺
  - Delphi
  - Windows编程
  - UX
  - 用户体验
  - CathyEagle
  - 存档
  - csdn
---

> 本文转载自[我200年在csdn发布的博客](https://blog.csdn.net/CathyEagle/article/details/244592)

## 摘要

在`Delphi`的`VCL`库中，为了使用以及实现的方便，应用对象`Application`创建了一个用来处理消息响应的隐藏窗口。而正是这个窗口，使得用`VCL`开发出来的程序存在着与其他窗口不能正常排列平铺等显得有些畸形的问题。本文通过对`VCL`的深入分析，给出了一个只需要对应用程序项目文件作3行代码的修改就能解决问题的方案，且不需要原有的编程方式作任何改变。

## 1. 引言

用`Delphi`所提供的`VCL`类库编写的`Windows`应用程序，有一个明显不同于标准`Windows`窗口的特点--主窗口的系统菜单与任务栏上的系统菜单不相同。一般情况下，主窗口的系统菜单有六个菜单项而任务栏系统菜单只有三个菜单项。实际使用中我们发现用`VCL`开发的程序有以下几个方面的尴尬：

1) 不够美观。这是肯定的，与标准不符自然会显得有些畸形。
   
2) 主窗口最小化时没有动画效果。
   
3) 窗口不能正常与其它窗口排列平铺。
   
4) 任务栏系统菜单具有最高的优先级。在存在模态窗口的情况下整个程序仍然可以被最小化，与模态窗口的设计相违背。

主窗口最小化动画效果的问题在`Delphi` 5.0以后的版本中已通过Forms.pas中的`ShowWinNoAnimate`函数解决，但其余几个问题则一直存在。尽管多数情况下这不会对应用程序带来什么影响，但在一些追求专业效果的场合确实不可接受的。由于`C++ Builder`与`Delphi`使用的是同一套类库，所以上述问题同样存在于使用`C++ Builder`编写的`Windows`应用程序中。

在[以前的文章](https://eagleboost.com/2000/08/14/Delphi-%E7%A8%8B%E5%BA%8F%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB%E5%8F%8A%E6%AD%A3%E5%B8%B8%E6%8E%92%E5%88%97%E5%B9%B3%E9%93%BA%E7%9A%84%E5%AE%9E%E7%8E%B0v1/)里，我已讨论过这个问题，当时的叙述看起来基本上是一种取巧的方法，而我也是在偶然之中才找到那个方法的。本文的任务就是通过对`VCL`类库作一些分析，说明那样做的原理，其次再给出一个只用3行代码的方法，完完全全地解决`Delphi`中这个"非正常窗口"的问题。

## 2. 原理

1) 应用程序的创建过程

下面是一个典型的应用程序的`Delphi`工程文件，我们注意到一开始就有一个对`Application`对象的`Initialize`方法的引用，我们的分析也就从这里开始：

```pascal
program Project1;
uses  
  Forms,  
  Unit1 in 'Unit1.pas' {Form1};
{$R *.res}
begin  
  Application.Initialize;
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.
```

隐藏的窗口是由`Application`对象创建的，那么`Application`对象又从何而来呢？在`Delphi`的代码编辑窗口中按住Ctrl点击`Application`就会发现，`Application`对象是在Forms.pas单元中定义的几个全局对象之一。这还不够，我们想要知道的是`Application`对象是在什么地方创建的，因为必须成功创建了T`Application`类的实例我们才能引用它。

想一下，有什么代码会在Application.`Initialize`之前执行呢？对了，是`initialization`代码段中的代码。认真调试过`VCL`源码就可以知道，`VCL`中很多单元都有`initialization`代码段，启动`Delphi`程序时，先是按照uses的顺序执行每个单元中`initialization`代码段的代码，完成所有的初始化动作之后才执行`Application`的`Initialize`方法以初始化`Application`，所以很显然，`Application`对象是在某个单元的`initialization`代码段中创建的。以`TApplication.Create`为关键字在`VCL`源码目录中搜索一番，我们果然在Controls.pas单元中找到了创建`Application`对象的代码。在Controls.pas单元的`initialization`代码段，有一句对`InitControls`过程的调用，而`InitControls`的实现则如下所示：

```pascal
Unit 
  Controls;
  ...    
initialization
  ...    
  InitControls;
procedure InitControls;
begin
  ...  
  Mouse := TMouse.Create;
  Screen := TScreen.Create(nil);
  Application := TApplication.Create(nil);
  ...
end;
```

好，到这里我们的分析就完成了第一步，因为要解决非正常窗口的问题，我们必须要在`Application`对象初始化之前做一件事，因此了解应用程序的初始化过程就非常重要了。

2) `IsLibrary`变量

`IsLibrary`变量是在System.pas单元中定义的全局标志变量之一。如果`IsLibrary`的值为true则表明程序模块是一个动态链接库，反之就是一个可执行程序。`VCL`类库中的某些过程就根据这个标志变量的不同值完成不同的动作。也就是这个变量，在解决`Delphi`的非正常窗口问题中起到了关键性的作用。

前面说过，为了方便，`Application`对象初始化时创建了一个看不见的窗口（也就是用`Spy++`之类的工具看到的那个以"T`Application`"为类名的窗口），但也正是因为这个看不见的窗口，才使得用`Delphi`开发出来的程序呈现诸多畸形。好了，如果我们能够去掉这个看不见的窗口（同时去掉任务栏系统菜单），代之以我们的应用程序主窗口，岂不是所有的问题都解决了？

说说简单，但实现起来需要对`VCL`源代码动大手术吗？如果那样岂不是有点本末倒置了？答案当然是不会，否则也不会有这篇文章了。在此我想说的是，在接下来的分析中，我们将会看到，所谓"编程之道，存乎一心"，T`Application`设计中无心插柳的做法，实则为我们解决这一问题留下了接口。不做源代码的分析，你可能要绕打圈子，而实际上我们会看到，天才的设计留给我们用的东西，不多也不少，刚刚好。

打开T`Application`类的构造函数Create，我们会发现这样一行代码。

```pascal
constructor TApplication.Create(AOwner: TComponent);
begin
  ...
  if not IsLibrary then CreateHandle;
  ...
end;
```

这里说的是，如果程序模块不是动态链接库，那么就执行`CreateHandle`，而`CreateHandle`所做的工作在帮助中是这样说的："如果不存在应用程序窗口，那就创建一个"，这里的"应用程序窗口"就是上面所说的看不见的窗口，也即是罪魁祸首之所在，在T`Application`类中用`FHandle`变量来保存其窗口句柄。这里就是根据`IsLibrary`的值完成了不同的动作，因为在动态链接库中一般并不需要消息循环的，但用`VCL`开发动态链接库还是要用到`Application`对象，所以有了这里的设计。好，我们只需要欺骗一下`Application`对象，在它创建之前把`IsLibrary`赋值为true，即可滤掉`CreateHandle`的执行，去掉这个讨厌的窗口了。

为`IsLibrary`赋值的代码显然也应该放在某个单元的`initialization`代码段中，而且由于`initialization`代码段中的代码是按照包含的单元的顺序执行的，为了保证在`Application`对象创建之前把`IsLibrary`赋值为true，在工程文件中我们必需将包含赋值代码的单元放在Forms单元之前，如下（假设该单元名为`UnitDllExe.pas`）：

```pascal
program Template;
uses  
  UnitDllExe in 'UnitDllExe.pas',
  Forms,  
  FormMain in 'FormMain.pas' {MainForm},  
  ...
```
`UnitDllExe.pas`代码清单如下：

```pascal
unit 
  UnitDllExe;
interface
implementation
initialization
  IsLibrary := true;//告诉Applciation对象，这是一个动态链接库，不需要创建隐藏窗口。end.
```

好了，编译运行一下，我们看到，由于没有创建隐藏窗口，原先任务栏上的系统菜单消失了，换成了主窗口的系统菜单，主窗口也能够与其它`Windows`窗口正常排列平铺。但带来的问题是窗口无法最小化。怎么回事呢？还是老方法，跟踪一下。

3) 主窗口最小化

最小化属于系统命令，最终必定是调用`API`函数`DefWindowProc`来将窗口最小化，所以我们毫无困难地就找到了`TCustomForm`中响应`WM_SYSCOMMAND`消息的函数`WMSysCommand`，其中清楚地写到将最小化的消息重定向到`Application.WndProc`去处理:

```pascal
procedure TCustomForm.WMSysCommand(var Message: TWMSysCommand);
begin  
  with Message do  
  begin    
    if (CmdType and $FFF0 = SC_MINIMIZE) and (Application.MainForm = Self) then
      Application.WndProc(TMessage(Message))
  ...  
  end;
end;
```

而在`Application.WndProc`中，响应最小化消息时又调用了`Application`的`Minimize`方法，所以症结一定是在`Minimize`过程。

```pascal
procedure TApplication.WndProc(var Message: TMessage);
...
begin  
  ...    
  with Message do      
    case Msg of 
      WM_SYSCOMMAND:
        case WParam and $FFF0 of 
          SC_MINIMIZE: Minimize;
          SC_RESTORE: Restore;
        else  
          Default;
  ...
end;
```

最后，找到`TApplication.Minimize`，就一切都明白了。这里对于`DefWindowProc`函数的调用没有产生任何效果，为什么呢？由于前面我们欺骗`Application`对象，滤掉了`CreateHandle`的调用，没有创建`Application`对象响应消息所需要的窗口，因此导致其句柄`FHandle`为0，调用当然不成功了。如果能将`FHandle`指向我们的应用程序主窗口就能解决问题。

```pascal
procedure TApplication.Minimize;
begin
  ...
  DefWindowProc(FHandle, WM_SYSCOMMAND, SC_MINIMIZE, 0);
  //这里FHandle值为0
  ...
end;
```

## 3 实现

Borland的天才们无心插柳的设计再一次让我们找到了解决问题的办法。由前面的分析我们知道，在用`VCL`开发的动态链接库中并没有创建隐藏的窗口来接收`Windows`消息（`CreateHandle`不执行），但在动态链接库中如果要显示窗口的话又需要一个父窗口。如何解决这个问题呢？`VCL`的设计者将保存看不见的窗口句柄的`FHandle`变量设计为可写，于是我们实际上可以简单地给`FHandle`赋一个值来为需要显示的子窗口提供一个父窗口。例如，在某个动态链接库插件中要显示窗体，我们通常会在主模块可执行文件中将`Application`对象的句柄通过动态链接库的某个函数传入并赋值给动态链接库的`Application.Handle`，类似于：

```pascal
procedure SetApplicationHandle(MainAppWnd: HWND)
begin
  Application.Handle := MainAppWnd;
end;
```

好了，既然`Aplication.Handle`实际上只是一个在内部用来响应消息的窗口句柄，而原本应该创建的看不见的窗口被我们去掉了，那我们只需要给出一个窗口的句柄，用来代替那个原本多余的隐藏窗口的句柄不就行了？这样的窗口去哪里找？应用程序的主窗口正是上上之选，于是有了下面的代码。

```pascal
program Template;
uses  
  UnitDllExe in 'UnitDllExe.pas',  
  Forms,  
  FormMain in 'FormMain.pas' {MainForm};
{$R *.res}
begin  
  Application.Initialize;
  Application.CreateForm(TFormMain, FormMain);
  Application.Handle := FormMain.Handle;
  Application.Run;
end.
```

于是，一切问题都解决了。你不需要对`VCL`源码作任何修改，不需要对原有的程序作任何修改，只要在工程文件中增加两行代码，加上`UnitDllExe.pas`中的一行，共三行代码，即可使得你的应用程序窗口完全和任何一个标准`Windows`窗口一样正常。

1) 任务栏和窗口标题栏拥有一致的系统菜单。

2) 主窗口最小化时有动画效果。

3) 窗口能够正常与其它窗口排列平铺。

4) 存在模态窗口时不能对其父窗口进行操作。
   
以上实现代码使用于`Delphi`的所有版本。
