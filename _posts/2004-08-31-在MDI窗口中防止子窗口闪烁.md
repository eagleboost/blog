---
layout:     post
title:      "在MDI窗口中防止子窗口闪烁"
subtitle:   "——谨以怀念用Win32 SDK/MFC编程的青春岁月"
date:       2004-08-31 18:24:00
author:     "eagleboost"
header-img: "img/post-bg-galaxy.jpg"
catalog: true
tags:
    - MFC
    - MDI
    - 子窗口闪烁
    - CathyEagle
    - 存档
    - csdn
---

> 本文转载自[我2004年在csdn发布的博客](https://blog.csdn.net/CathyEagle/article/details/90329)

## 引言

用Visual Studio的App Wizard创建MDI项目后，我们会发现在子窗口（CMDIChildWnd）处于最大化状态时常会发生闪烁现象（尤其是内嵌浏览器时），一般说来有如下几种情况：

1. 当前子窗口处于最大化状态时创建新的窗口，会看到一个矩形闪烁的过程。   
2. 切换窗口时闪烁现象并不明显，但在窗口边缘仍然存在（调用MDINext和MDIPrev不会出现闪烁，而调用MDIActivate则会引起闪烁）。
3. 如果MainFrame上有其它停靠的面板（CControlBar），则调用ShowControlBar显示/隐藏面板时，子窗口边界会有闪烁现象。

## 解决方法：

1) 重载`PreCreateWindow`，此方法能够解决上述前两种情况的闪烁问题：

```c++
BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{ 
  //把窗口样式设置为最大化，但先不显示，问题1
  cs.style = WS_CHILD | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU  | FWS_ADDTOTITLE | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX   | WS_MAXIMIZE;  
  cs.cx = 1024;   //把窗口大小设置为整个屏幕大小，问题2 
  cs.cy = 768;
  if( !CMDIChildWndEx::PreCreateWindow(cs) )  
    return FALSE;
  cs.style |= WS_VISIBLE;  //创建完成只之后再显示窗口，问题1
  return TRUE;
}
```

2) 第3个问题的方法是处理MainFrame的MDI client区域，MainFrame（CMDIFrameWnd）的的MDI client窗口句柄保存在成员变量m_hWndMDIClient中，只需要在调用ShowControlBar之前将该窗口的更新锁定，调用完ShowControlBar后再恢复更新即可消除闪烁，方法可以解决所有子窗口改变引起的闪烁，例子如下：

```c++
// 切换显示左边的面板
void CMainFrame::ToggleLeftPane(CControlBar & pBar)
{ 
  ::SendMessage(m_hWndMDIClient, WM_SETREDRAW, FALSE, 0L); 
  ShowControlBar( &pBar, !pBar.IsVisible(), FALSE ); 
  ::SendMessage(m_hWndMDIClient, WM_SETREDRAW, TRUE, 0L); 
  ::RedrawWindow(m_hWndMDIClient, NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE);//强制重绘，包括子窗口
}
```

调用MDIActivate切换子窗口引起的闪烁同样可以解决，但只需要用`SetRedraw`即可，

```c++
 ::SendMessage(m_hWndMDIClient, WM_SETREDRAW, FALSE, 0L); 
 MDIActivate( pTmpChild ); 
 ::SendMessage(m_hWndMDIClient, WM_SETREDRAW, TRUE, 0L); 
 ::RedrawWindow(m_hWndMDIClient, NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE);
```

至于原理，我认为是封装的缘故，为了保证窗口的内容的更新，重绘的操作时时在发生，如果重绘不够快且每个窗口都在重绘的话，闪烁就产生了，所以适当的时候禁止窗口重绘，适当的时候再恢复，就可以解决问题。
不过总是在操作窗口之前锁定更新，操作之后又恢复更新麻烦了一点，似乎应该能够找到两个合适的位置来放置这两句话，起到一劳永逸的效果。对于第三种情况，可以简单地通过子类化m_hWndMDIClient，在`WM_WINDOWPOSCHANGING`和`WM_WINDOWPOSCHANGED`的消息响应处理过程中分别锁定更新和恢复更新来实现，但在前两种情况下，窗口重绘时涉及两个窗口，就比较麻烦了。