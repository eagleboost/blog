---
layout:     post
title:      "再谈动态创建网页元素"
subtitle:   "——谨以怀念写邮件回答网友关于Internet Explorer编程问题的青春岁月"
date:        2006-12-10 11:03:00
author:     "eagleboost"
header-img: "img/post-bg-desktop.jpg"
catalog:    true
tags:
  - Internet Explorer编程FAQ
  - Internet Explorer编程
  - IHTMLOptionElementFactory
  - IHTMLImageElementFactory
  - createElement
  - CathyEagle
  - 存档
  - csdn
---

> 本文转载自[我2006年在csdn发布的博客](https://blog.csdn.net/CathyEagle/article/details/1437075)

## 1、 概述

在《[FAQ：操纵下拉列表](https://eagleboost.com/2004/10/15/FAQ-%E6%93%8D%E7%BA%B5%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/)》中我曾写到如何调用`IHTMLDocument2::createElement`和`IHTMLSelectElement::add`动态为`IHTMLSelectElement`添加表项：

```c++
//先调用IHTMLDocument2::createElement创建一个option对象，

HRESULT createElement(          
    BSTR eTag,               //标签名，可以是img, area, option(ie4), frame, iframe(ie5)
    IHTMLElement **newElem   //返回对象指针
);

//再调用IHTMLSelectElement::add将创建的option对象添加到列表中

HRESULT add(          
    IHTMLElement *element,
    VARIANT before   //添加到哪个位置，VT_I4类型的VARIANT
);
```

方法来自

```javascript
  var oOption = document.createElement("OPTION");
  oOption.text="Ferrari";
  oOption.value="4";
  oSelect.add(oOption);
```

但事实上类似的代码在`C++`中却不能工作。

## 2、 发现

写文章时测试过脚本调用之后就放在一边了，而真正写程序用到时才发现上面的问题。`MFC`中有个很好用的类`CDHtmlDialog`，提供了类似于`CDialog`的行为用以实现以`HTML`为表现形式的对话框，像`Visual Studio 7/8`的`Wizard`，添加类等对话框就使用了类似的技术。`CDHtmlDialog`的核心在于`MFC`中被用得出神入化的宏，再加上一系列`DDX`函数来实现`HTML content`和应用程序的数据的数据交换。比如下面的函数可以实现读取某个能够匹配`szId`的`IHTMLSelectElement`中被选中的值，或选中`value`所指定的那个`IHTMLOptionElement`。


```c++
void CDHtmlDialog::DDX_DHtml_SelectString(LPCTSTR szId, CString& value, BOOL bSave)
{
  CComPtr<IHTMLDocument2> sphtmlDoc;
  GetDHtmlDocument(&sphtmlDoc);
  if (sphtmlDoc == NULL)
    return;

  COleVariant varEmpty, varIndex;

  CComPtr<IHTMLSelectElement> spSelect;
  CComPtr<IDispatch> spdispOption;
  CComPtr<IHTMLOptionElement> spOption;
  CComBSTR bstrText;
  HRESULT hr = S_OK;
  long lIndex=-1;

  hr = GetElementInterface(szId, __uuidof(IHTMLSelectElement), (void **) &spSelect);
  if (spSelect == NULL)
    return;

  if (bSave)
  {
    // get the selected item
    value.Empty();
    spSelect->get_selectedIndex(&lIndex);
    if (lIndex >= 0)
    {
      varIndex = lIndex;

      spSelect->item(varIndex, varEmpty, &spdispOption);
      if (spdispOption)
      {
        spdispOption->QueryInterface(__uuidof(IHTMLOptionElement), (void **) &spOption);
        if (spOption)
        {
          spOption->get_text(&bstrText);
          if (bstrText)
            value = bstrText;
        }
      }
    }
  }
  else
  {
    bstrText.Attach(value.AllocSysString());
    lIndex = Select_FindString(spSelect, bstrText, FALSE);
    spSelect->put_selectedIndex(lIndex);
  }
}
```

但`MFC`只提供了比较基本的交换函数，更复杂的的数据交换则需要自己实现了。比如我有一个`CStringArray`，希望能以`CStringArray`中的每个字符串为`Value`动态创建`IHTMLOptionElement`并添加到`IHTMLSelectElement`，或者将所有`IHTMLSelectElement`中`IHTMLOptionElement`的`Value`作为字符串保存到`CStringArray`中，该怎么办呢？
 
很简单啊，用文章开头说到的方法动态创建`IHTMLOptionElement`不就行了。但实际上虽然程序运行不保错，但`MSHTML`似乎没有任何反应。看来`createElement`只能用脚本调用了，《[FAQ: 如何动态创建并访问网页元素](https://eagleboost.com/2006/11/18/FAQ-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0/)》一文中讨论的问题也证明了这一点。同时，在那篇文章中能解决问题的`insertAdjacentHTML`对于`IHTMLSelectElement`和`IHTMLOptionElement`也没有用。

## 3、 方案

第一反应当然是上网搜了。我于是发现有个朋友在《[FAQ：操纵下拉列表](https://eagleboost.com/2004/10/15/FAQ-%E6%93%8D%E7%BA%B5%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/)》的`CSDN`文档中心版本作了如下的回复：

 
> According to MSDN, “Before you can add an element to a collection, you must create it first by using the IHTMLDocument2::createElement method”. Actually, it does not work.
> 
> See the detail in codeproject  

`codeproject`的这篇文章，指的是《[How to operate controls in an HTML file using C++](https://www.codeproject.com/Articles/3432/How-to-operate-controls-in-an-HTML-file-using-C)》，其中说到应该使用`IHTMLOptionElementFactory`来创建`IHTMLOptionElement`。而`IHTMLOptionElementFactory`需要从`IHTMLWindow2`（该文说应该从`Document`的`Script`来获得`IHTMLWindow2`，其实从`Document`的`parentWindow`更为直接）的`Option`来得到，再看`MSDN`，我们发现同样还有一个`IHTMLImageElementFactory`接口（从`IHTMLWindow2`的`Image`得到）用于创建`IHTMLImgElement`。看来要么这两个接口有特殊的地方，要么就是历史遗留问题了。因为令人感到奇怪的是`MSDN`中关于`IHTMLDocument2::createElement`方法的说明对这两个接口只字不提：

> In Microsoft Internet Explorer 4.0, the only new elements you can create are img, area, and option. As of Internet Explorer 5, you can create all elements programmatically, except for frame and iframe. In addition, the properties of these created elements are read/write and can be accessed programmatically. Before you use new objects, you must explicitly add them to their respective collections or to the document. To insert new elements into the current document, use the `IHTMLDOMNode::insertBefore` or `IHTMLDOMNode::appendChild` methods. 
>
> Attributes can be included with the eTag as long as the entire string is valid HTML. 

## 4、 示例

下面的函数演示了如何使用`IHTMLOptionElementFactory`来实现前面我们希望完成的功能，

```c++
void CMyDHtmlDialog::DDX_DHtml_SelectOptions(CDataExchange* pDX, LPCTSTR szId, CMIEStringArray& value)
{
  CComPtr<IHTMLDocument2> sphtmlDoc;
  GetDHtmlDocument(&sphtmlDoc);
  if (sphtmlDoc == NULL)
    return;

  COleVariant varEmpty, varIndex;

  HRESULT hr = S_OK;
  CComPtr<IHTMLSelectElement> spSelect;
  hr = GetElementInterface(szId, __uuidof(IHTMLSelectElement), (void **) &spSelect);
  if (spSelect == NULL)
    return;

  if (pDX->m_bSaveAndValidate)
  {
    // get the selected item
    value.RemoveAll();
    long length = 0;
    spSelect->get_length(&length);

    for (long lIndex = 0; lIndex < length; lIndex++)
    {
      varIndex = lIndex;
      CComPtr<IDispatch> spdispOption;
      spSelect->item(varIndex, varEmpty, &spdispOption);
      if (spdispOption)
      {
        CComPtr<IHTMLOptionElement> spOption;
        spdispOption->QueryInterface(__uuidof(IHTMLOptionElement), (void **) &spOption);
        if (spOption)
        {
          CComBSTR bstrText;
          spOption->get_text(&bstrText);
          if (bstrText)
          {
            value.Add(bstrText);
          }
        }
      }
    }
  }
  else
  {
    long length = 0;
    spSelect->get_length(&length);
    for (long lIndex = 0; lIndex < length; lIndex++)
    {
      spSelect->remove(0);
    }

    CComQIPtr<IHTMLWindow2> spWindow;
    if ( FAILED(sphtmlDoc->get_parentWindow(&spWindow)) || !spWindow )
      return;

    CComQIPtr<IHTMLOptionElementFactory> spOptionFactory;
    if ( FAILED(spWindow->get_Option(&spOptionFactory)) || !spOptionFactory )
      return;

    // Add each items to selection
    for (long lIndex = 0; lIndex < value.GetCount(); lIndex++)
    {
      CString strOption = value[lIndex];

      // Get current item in the dictionary
      IHTMLOptionElement * pOption;
      VARIANT_BOOL vt_b = lIndex == 0 ? VARIANT_TRUE : VARIANT_FALSE;
      if ( FAILED(spOptionFactory->create(CComVariant(strOption), CComVariant(strOption),  CComVariant(vt_b), CComVariant(vt_b), &pOption)) || !pOption )
        continue;

      // Add to selection tag
      if ( FAILED(spSelect->add((IHTMLElement*)pOption, CComVariant(lIndex))) )
        continue;
    }
  }
}
```

### 参考资料

《[FAQ：操纵下拉列表](https://eagleboost.com/2004/10/15/FAQ-%E6%93%8D%E7%BA%B5%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/)》

《[FAQ: 如何动态创建并访问网页元素](https://eagleboost.com/2006/11/18/FAQ-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0/)》

《[CSDN技术中心 FAQ：操纵下拉列表](http://dev.csdn.net/article/43/43080.shtm)》（原链接已失效）

《[How to operate controls in an HTML file using C++](https://www.codeproject.com/Articles/3432/How-to-operate-controls-in-an-HTML-file-using-C)》